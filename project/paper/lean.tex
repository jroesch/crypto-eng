\section{Lean}

Lean is a new theorem proving environment from Microsoft Research. It has
been designed to be a modern, highly performant implementation by leveraging
state of the art ideas in constraint solving and synthesis, as well as
providing the flexibility to explore new ideas in type theory such as
Homotopy Type Theory\cite{HoTTbook}.

It key features are:\\
\begin{itemize}
    \item powerful elaboration engine
    \item small trusted kernel
    \item flexible kernel
    \item incremental compilation
    \item universe polymorphism
    \item mixed declarative and tactic proof style
    \item powerful automation\\
\end{itemize}

\subsection{Theorem Proving}

Theorem Proving has been an area of active research for many decades. It is
apparent that the  verification of semantic properties are desirable for
work in high assurance software systems, computer science and mathematics.
There have been various approaches to Automated Theorem Proving in the past ACL2,
NuPRL, LF, LCF, Coq, Agda, and Lean. The ones based on dependent type
theories seem to be the most promising for various reasons:\\

\begin{itemize}
    \item dependent types correspond to higher-order logic
    \item tools for automated proof search and generation
    \item specification and implementation happen in the same language
    \item executable "proofs" (i.e program extraction)\\
\end{itemize}

\subsection{Type Theory}

The programming language community has a long history with type theory, a
computational proof theory that allows us to equate programs with proofs,
and types with propositions.

Type theory is at its core a foundational framework for mathematics. It was a
school of thought that evolved out of Russel's work on foundational systems. One of the
key insights in its developement and adoption was the Curry-Howard Isomorphism,Ã¥
which states that types can be associated with propositions and proofs with programs.
This allows one to write down a specification (a type) satisfy it with
a program (a proof) and then execute the program for a result. Because
of this type theory should be interesting to computer scientists, it means our
foundations can simply be a programming language.

Traditional programming languages have often treated types as a means of enforcing
memory layout, like in C, but they can be much richer. Traditional type systems
are very rigid and maintain a strict phase distinction; types and values
live in separate universes. If we ease this restriction and freely allow programmers
to intersperse types and values we end up dependent types, which happen to
correspond to higher order logic. This is of course a very brief overview
and more information can be found in \cite{Pierce:TypeSystems} \cite{martinlof}
and \cite{HoTTbook}.

From a theoretical perspective the majority of interesting mathematics and
and verification can be formalized using a small set of features from dependent
type theory:\\

\begin{itemize}
    \item type universes
    \item dependent function spaces
    \item inductive types\\
\end{itemize}

The key concept is that of a dependent function space or $\Pi$ type.
A $\Pi$ type represents a function where the codomain is dependent on the value
of the domain. Logically this means our propositions can be predicated on the
value of their parameters. We can extend a lambda calculs with dependent functions
with inductive types to have something powerful enough to implement a
theorem proving environment and formalize large chunks of mathematics.

Inductive types makes this possible; they define a type, a set of type formers
(constructors) and an elimnator (or computation rule). We can use these to build
up data types that represent data structures or proofs and compute based on them
via eliminaton rules.

Lean implements many other nice features by elaborating them to these simple
core constructs. Lean's focus on engineering quality has made it an attractive
choice for this project.

% features. The first of which is type universes which allows us to resolve
% soundness issues, in a dependently typed environment we must ask the question:
% if we can use types as values what is the type of types? does the type of all types contain itself?
% The astute reader will notice that this question is similar to Russel's Paradox.
% We solve it much the same way by constructing an infinite hierarchy of universes
% where each one contains all previous universes. T
